<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/group_7/studysage/viewmodels/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/group_7/studysage/viewmodels/HomeViewModel.kt" />
              <option name="originalContent" value="package com.group_7.studysage.viewmodels&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import androidx.compose.runtime.State&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.group_7.studysage.data.repository.AuthRepository&#10;import com.group_7.studysage.data.repository.Note&#10;import com.group_7.studysage.data.repository.NotesRepository&#10;import kotlinx.coroutines.launch&#10;&#10;class HomeViewModel(&#10;    private val notesRepository: NotesRepository = NotesRepository(),&#10;    private val authRepository: AuthRepository = AuthRepository()&#10;) : ViewModel() {&#10;&#10;    private val _isLoading = mutableStateOf(false)&#10;    val isLoading: State&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _uploadStatus = mutableStateOf&lt;String?&gt;(null)&#10;    val uploadStatus: State&lt;String?&gt; = _uploadStatus&#10;&#10;    private val _errorMessage = mutableStateOf&lt;String?&gt;(null)&#10;    val errorMessage: State&lt;String?&gt; = _errorMessage&#10;&#10;    private val _processedNote = mutableStateOf&lt;Note?&gt;(null)&#10;    val processedNote: State&lt;Note?&gt; = _processedNote&#10;&#10;    private val _recentNotes = mutableStateOf&lt;List&lt;Note&gt;&gt;(emptyList())&#10;    val recentNotes: State&lt;List&lt;Note&gt;&gt; = _recentNotes&#10;&#10;    private val _testResult = mutableStateOf&lt;String?&gt;(null)&#10;    val testResult: State&lt;String?&gt; = _testResult&#10;&#10;    // Fetch user full name from Firebase Firestore&#10;    private val _userFullName = mutableStateOf(&quot;User&quot;)&#10;    val userFullName: State&lt;String&gt; = _userFullName&#10;&#10;    private val _userProfile = mutableStateOf&lt;Map&lt;String, Any&gt;?&gt;(null)&#10;    val userProfile: State&lt;Map&lt;String, Any&gt;?&gt; = _userProfile&#10;&#10;    private val _isLoadingProfile = mutableStateOf(true)&#10;    val isLoadingProfile: State&lt;Boolean&gt; = _isLoadingProfile&#10;&#10;    private val _recentlyOpenedPdfs = mutableStateOf&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt;(emptyList())&#10;    val recentlyOpenedPdfs: State&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt; = _recentlyOpenedPdfs&#10;&#10;    private val _courseNotes = mutableStateOf&lt;List&lt;Note&gt;&gt;(emptyList())&#10;    val courseNotes: State&lt;List&lt;Note&gt;&gt; = _courseNotes&#10;&#10;    init {&#10;        loadRecentNotes()&#10;        loadUserProfile()&#10;        loadRecentlyOpenedPdfs()&#10;        initializeSampleData()&#10;    }&#10;&#10;    // Load user profile from Firestore&#10;    private fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            _isLoadingProfile.value = true&#10;            try {&#10;                val profile = authRepository.getUserProfile()&#10;                _userFullName.value = (profile?.get(&quot;name&quot;) as? String) ?: &quot;User&quot;&#10;                _userProfile.value = profile  // Store full profile data&#10;            } catch (e: Exception) {&#10;                _userFullName.value = &quot;User&quot;&#10;                _userProfile.value = null&#10;                _errorMessage.value = &quot;Failed to load profile&quot;&#10;            } finally {&#10;                _isLoadingProfile.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Public method to refresh user name&#10;    fun refreshUserProfile() {&#10;        loadUserProfile()&#10;    }&#10;&#10;    // Updated method to accept courseId parameter&#10;    fun uploadAndProcessNote(&#10;        context: Context,&#10;        uri: Uri,&#10;        fileName: String,&#10;        courseId: String? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _errorMessage.value = null&#10;            clearMessages()&#10;&#10;            try {&#10;                // Validate file type&#10;                val supportedTypes = listOf(&quot;.pdf&quot;, &quot;.txt&quot;, &quot;.doc&quot;, &quot;.docx&quot;, &quot;.md&quot;, &quot;.rtf&quot;)&#10;                val isSupported = supportedTypes.any { fileName.endsWith(it, ignoreCase = true) }&#10;&#10;                if (!isSupported) {&#10;                    _errorMessage.value = &quot;Unsupported file type. Please upload PDF, TXT, DOC, or DOCX files.&quot;&#10;                    _isLoading.value = false&#10;                    return@launch&#10;                }&#10;&#10;                // Check file size (limit to 10MB). Use `use` so the InputStream is closed after reading.&#10;                val fileSize = context.contentResolver.openInputStream(uri)?.use { it.available() } ?: 0&#10;                if (fileSize &gt; 10 * 1024 * 1024) { // 10MB limit&#10;                    _errorMessage.value = &quot;File too large. Please upload files smaller than 10MB.&quot;&#10;                    _isLoading.value = false&#10;                    return@launch&#10;                }&#10;&#10;                val result = notesRepository.uploadNotesAndProcess(&#10;                    context = context,&#10;                    uri = uri,&#10;                    fileName = fileName,&#10;                    courseId = courseId, // Pass the courseId&#10;                    onProgress = { status -&gt;&#10;                        _uploadStatus.value = status&#10;                    }&#10;                )&#10;&#10;                result.onSuccess { note -&gt;&#10;                    _processedNote.value = note&#10;                    _uploadStatus.value = &quot;Document processed successfully!&quot;&#10;                    loadRecentNotes() // Refresh the notes list&#10;                }.onFailure { exception -&gt;&#10;                    val errorMsg = when {&#10;                        exception.message?.contains(&quot;authentication&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;Please sign in to upload files&quot;&#10;                        exception.message?.contains(&quot;network&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;Network error. Please check your connection&quot;&#10;                        exception.message?.contains(&quot;API&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;AI processing temporarily unavailable. Please try again&quot;&#10;                        exception.message?.contains(&quot;PDF&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;PDF processing failed. Please try a different file&quot;&#10;                        else -&gt; &quot;Error processing file: ${exception.message}&quot;&#10;                    }&#10;                    _errorMessage.value = errorMsg&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Unexpected error: ${e.message}&quot;&#10;            }&#10;&#10;            _isLoading.value = false&#10;        }&#10;    }&#10;&#10;    private fun loadRecentNotes() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val notes = notesRepository.getUserNotes()&#10;                _recentNotes.value = notes.take(5) // Show only last 5 notes&#10;            } catch (e: Exception) {&#10;                // Handle error silently for now, or show a subtle error&#10;                _errorMessage.value = &quot;Failed to load recent notes&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadRecentlyOpenedPdfs() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val pdfs = authRepository.getUserLibrary()&#10;                _recentlyOpenedPdfs.value = pdfs&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to load recently opened PDFs&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeSampleData() {&#10;        viewModelScope.launch {&#10;            // Only initialize sample PDFs if no PDFs exist&#10;            if (authRepository.getUserLibrary().isEmpty()) {&#10;                authRepository.initializeSampleUserLibrary()&#10;                loadRecentlyOpenedPdfs()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getNotesForCourseFromLibrary(courseId: String): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return recentlyOpenedPdfs.value.filter { it[&quot;courseId&quot;] == courseId }&#10;    }&#10;&#10;    // New method to get full notes with summaries for a course&#10;    fun loadNotesForCourse(courseId: String) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                val notes = notesRepository.getNotesForCourse(courseId)&#10;                _courseNotes.value = notes&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to load course notes: ${e.message}&quot;&#10;                _courseNotes.value = emptyList()&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun openPdf(pdfUrl: String) {&#10;        // TODO: Navigate to PDF viewer&#10;        // navController.navigate(&quot;pdf_viewer/$pdfUrl&quot;)&#10;    }&#10;&#10;    fun refreshNotes() {&#10;        loadRecentNotes()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        _uploadStatus.value = null&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    fun clearProcessedNote() {&#10;        _processedNote.value = null&#10;    }&#10;&#10;    fun clearError() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    // Test connectivity methods (optional)&#10;    fun testAIConnection() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _testResult.value = &quot;Testing AI connectivity...&quot;&#10;&#10;            try {&#10;                // Simple test with a basic text file simulation&#10;                val testContent = &quot;This is a test document for AI processing.&quot;&#10;                val summary = notesRepository.generateAISummary(testContent)&#10;&#10;                if (summary.isNotBlank()) {&#10;                    _testResult.value = &quot;✅ AI connection successful&quot;&#10;                } else {&#10;                    _testResult.value = &quot;❌ AI connection failed&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _testResult.value = &quot;❌ AI test failed: ${e.message}&quot;&#10;            }&#10;&#10;            _isLoading.value = false&#10;        }&#10;    }&#10;&#10;    fun retryProcessing(context: Context, uri: Uri, fileName: String, courseId: String? = null) {&#10;        // Clear previous errors and try again&#10;        clearMessages()&#10;        uploadAndProcessNote(context, uri, fileName, courseId)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.group_7.studysage.viewmodels&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import androidx.compose.runtime.State&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.group_7.studysage.data.repository.AuthRepository&#10;import com.group_7.studysage.data.repository.Note&#10;import com.group_7.studysage.data.repository.NotesRepository&#10;import kotlinx.coroutines.launch&#10;&#10;class HomeViewModel(&#10;    private val notesRepository: NotesRepository = NotesRepository(),&#10;    private val authRepository: AuthRepository = AuthRepository()&#10;) : ViewModel() {&#10;&#10;    private val _isLoading = mutableStateOf(false)&#10;    val isLoading: State&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _uploadStatus = mutableStateOf&lt;String?&gt;(null)&#10;    val uploadStatus: State&lt;String?&gt; = _uploadStatus&#10;&#10;    private val _errorMessage = mutableStateOf&lt;String?&gt;(null)&#10;    val errorMessage: State&lt;String?&gt; = _errorMessage&#10;&#10;    private val _processedNote = mutableStateOf&lt;Note?&gt;(null)&#10;    val processedNote: State&lt;Note?&gt; = _processedNote&#10;&#10;    private val _recentNotes = mutableStateOf&lt;List&lt;Note&gt;&gt;(emptyList())&#10;    val recentNotes: State&lt;List&lt;Note&gt;&gt; = _recentNotes&#10;&#10;    private val _testResult = mutableStateOf&lt;String?&gt;(null)&#10;    val testResult: State&lt;String?&gt; = _testResult&#10;&#10;    // Fetch user full name from Firebase Firestore&#10;    private val _userFullName = mutableStateOf(&quot;User&quot;)&#10;    val userFullName: State&lt;String&gt; = _userFullName&#10;&#10;    private val _userProfile = mutableStateOf&lt;Map&lt;String, Any&gt;?&gt;(null)&#10;    val userProfile: State&lt;Map&lt;String, Any&gt;?&gt; = _userProfile&#10;&#10;    private val _isLoadingProfile = mutableStateOf(true)&#10;    val isLoadingProfile: State&lt;Boolean&gt; = _isLoadingProfile&#10;&#10;    private val _recentlyOpenedPdfs = mutableStateOf&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt;(emptyList())&#10;    val recentlyOpenedPdfs: State&lt;List&lt;Map&lt;String, Any&gt;&gt;&gt; = _recentlyOpenedPdfs&#10;&#10;    private val _courseNotes = mutableStateOf&lt;List&lt;Note&gt;&gt;(emptyList())&#10;    val courseNotes: State&lt;List&lt;Note&gt;&gt; = _courseNotes&#10;&#10;    init {&#10;        loadRecentNotes()&#10;        loadUserProfile()&#10;        loadRecentlyOpenedPdfs()&#10;        initializeSampleData()&#10;    }&#10;&#10;    // Load user profile from Firestore&#10;    private fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            _isLoadingProfile.value = true&#10;            try {&#10;                val profile = authRepository.getUserProfile()&#10;                _userFullName.value = (profile?.get(&quot;name&quot;) as? String) ?: &quot;User&quot;&#10;                _userProfile.value = profile  // Store full profile data&#10;            } catch (e: Exception) {&#10;                _userFullName.value = &quot;User&quot;&#10;                _userProfile.value = null&#10;                _errorMessage.value = &quot;Failed to load profile&quot;&#10;            } finally {&#10;                _isLoadingProfile.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Public method to refresh user name&#10;    fun refreshUserProfile() {&#10;        loadUserProfile()&#10;    }&#10;&#10;    // Updated method to accept courseId parameter&#10;    fun uploadAndProcessNote(&#10;        context: Context,&#10;        uri: Uri,&#10;        fileName: String,&#10;        courseId: String? = null&#10;    ) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _errorMessage.value = null&#10;            clearMessages()&#10;&#10;            try {&#10;                // Validate file type&#10;                val supportedTypes = listOf(&quot;.pdf&quot;, &quot;.txt&quot;, &quot;.doc&quot;, &quot;.docx&quot;, &quot;.md&quot;, &quot;.rtf&quot;)&#10;                val isSupported = supportedTypes.any { fileName.endsWith(it, ignoreCase = true) }&#10;&#10;                if (!isSupported) {&#10;                    _errorMessage.value = &quot;Unsupported file type. Please upload PDF, TXT, DOC, or DOCX files.&quot;&#10;                    _isLoading.value = false&#10;                    return@launch&#10;                }&#10;&#10;                // Check file size (limit to 10MB). Use `use` so the InputStream is closed after reading.&#10;                val fileSize = context.contentResolver.openInputStream(uri)?.use { it.available() } ?: 0&#10;                if (fileSize &gt; 10 * 1024 * 1024) { // 10MB limit&#10;                    _errorMessage.value = &quot;File too large. Please upload files smaller than 10MB.&quot;&#10;                    _isLoading.value = false&#10;                    return@launch&#10;                }&#10;&#10;                val result = notesRepository.uploadNotesAndProcess(&#10;                    context = context,&#10;                    uri = uri,&#10;                    fileName = fileName,&#10;                    courseId = courseId, // Pass the courseId&#10;                    onProgress = { status -&gt;&#10;                        _uploadStatus.value = status&#10;                    }&#10;                )&#10;&#10;                result.onSuccess { note -&gt;&#10;                    _processedNote.value = note&#10;                    _uploadStatus.value = &quot;Document processed successfully!&quot;&#10;                    loadRecentNotes() // Refresh the notes list&#10;                    // Refresh course notes if the note belongs to a course&#10;                    if (courseId != null) {&#10;                        loadNotesForCourse(courseId)&#10;                    }&#10;                }.onFailure { exception -&gt;&#10;                    val errorMsg = when {&#10;                        exception.message?.contains(&quot;authentication&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;Please sign in to upload files&quot;&#10;                        exception.message?.contains(&quot;network&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;Network error. Please check your connection&quot;&#10;                        exception.message?.contains(&quot;API&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;AI processing temporarily unavailable. Please try again&quot;&#10;                        exception.message?.contains(&quot;PDF&quot;, ignoreCase = true) == true -&gt;&#10;                            &quot;PDF processing failed. Please try a different file&quot;&#10;                        else -&gt; &quot;Error processing file: ${exception.message}&quot;&#10;                    }&#10;                    _errorMessage.value = errorMsg&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Unexpected error: ${e.message}&quot;&#10;            }&#10;&#10;            _isLoading.value = false&#10;        }&#10;    }&#10;&#10;    private fun loadRecentNotes() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val notes = notesRepository.getUserNotes()&#10;                _recentNotes.value = notes.take(5) // Show only last 5 notes&#10;            } catch (e: Exception) {&#10;                // Handle error silently for now, or show a subtle error&#10;                _errorMessage.value = &quot;Failed to load recent notes&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadRecentlyOpenedPdfs() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val pdfs = authRepository.getUserLibrary()&#10;                _recentlyOpenedPdfs.value = pdfs&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to load recently opened PDFs&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeSampleData() {&#10;        viewModelScope.launch {&#10;            // Only initialize sample PDFs if no PDFs exist&#10;            if (authRepository.getUserLibrary().isEmpty()) {&#10;                authRepository.initializeSampleUserLibrary()&#10;                loadRecentlyOpenedPdfs()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getNotesForCourseFromLibrary(courseId: String): List&lt;Map&lt;String, Any&gt;&gt; {&#10;        return recentlyOpenedPdfs.value.filter { it[&quot;courseId&quot;] == courseId }&#10;    }&#10;&#10;    // New method to get full notes with summaries for a course&#10;    fun loadNotesForCourse(courseId: String) {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            try {&#10;                val notes = notesRepository.getNotesForCourse(courseId)&#10;                _courseNotes.value = notes&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to load course notes: ${e.message}&quot;&#10;                _courseNotes.value = emptyList()&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun openPdf(pdfUrl: String) {&#10;        // TODO: Navigate to PDF viewer&#10;        // navController.navigate(&quot;pdf_viewer/$pdfUrl&quot;)&#10;    }&#10;&#10;    fun refreshNotes() {&#10;        loadRecentNotes()&#10;    }&#10;&#10;    fun clearMessages() {&#10;        _uploadStatus.value = null&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    fun clearProcessedNote() {&#10;        _processedNote.value = null&#10;    }&#10;&#10;    fun clearError() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    // Test connectivity methods (optional)&#10;    fun testAIConnection() {&#10;        viewModelScope.launch {&#10;            _isLoading.value = true&#10;            _testResult.value = &quot;Testing AI connectivity...&quot;&#10;&#10;            try {&#10;                // Simple test with a basic text file simulation&#10;                val testContent = &quot;This is a test document for AI processing.&quot;&#10;                val summary = notesRepository.generateAISummary(testContent)&#10;&#10;                if (summary.isNotBlank()) {&#10;                    _testResult.value = &quot;✅ AI connection successful&quot;&#10;                } else {&#10;                    _testResult.value = &quot;❌ AI connection failed&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _testResult.value = &quot;❌ AI test failed: ${e.message}&quot;&#10;            }&#10;&#10;            _isLoading.value = false&#10;        }&#10;    }&#10;&#10;    fun retryProcessing(context: Context, uri: Uri, fileName: String, courseId: String? = null) {&#10;        // Clear previous errors and try again&#10;        clearMessages()&#10;        uploadAndProcessNote(context, uri, fileName, courseId)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>